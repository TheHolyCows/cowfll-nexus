<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audience Display</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/display.css') }}">
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700;900&display=swap" rel="stylesheet">
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
</head>
<body>
    <!-- Match Overlay Mode -->
    <div id="matchOverlay" class="overlay-mode">
        <div class="upperThird">
            <div class="fllLogo"></div>
            <div id="timer">2:30</div>
            <div class="logo"></div>
            <div class="eventTitle">Southern California FLL Championship</div>
        </div>

        <div id="lowerThirdContainer" class="lowerThird">
            <div id="moTableContainer" class="tables">
                <!-- Tables will be dynamically inserted here -->
            </div>
        </div>
    </div>

    <!-- Rankings Overlay Mode -->
    <div id="rankingsOverlay" class="overlay-mode" style="display: none;">
        <div class="rkContainer">
            <div class="title">Rankings</div>
            <div id="rankingsContainer" class="lower">
                <table class="rankingTable">
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Team #</th>
                            <th>Team Name</th>
                            <th>High Score</th>
                            <th>Rounds</th>
                        </tr>
                    </thead>
                    <tbody id="rankingsBody">
                        <!-- Rankings will be dynamically inserted here -->
                    </tbody>
                </table>
            </div>
        </div>
        <div id="qrCodeContainer" class="qr-code-container">
            <div id="qrcode"></div>
            <div class="qr-label">
                <img src="https://fll.nexus/assets/images/icon.svg" alt="FLL Nexus" class="qr-logo">
                Leaderboard
            </div>
        </div>
    </div>

    <!-- Sponsors Mode -->
    <div id="sponsors" class="overlay-mode" style="display: none;">
        <div id="spLowerThird">
            <!-- Sponsor logos will be dynamically inserted here -->
        </div>
    </div>

    <!-- Blank Mode -->
    <div id="blank" class="overlay-mode" style="display: none;">
        <!-- Intentionally blank for chroma key -->
    </div>

    <!-- Event Info Mode -->
    <div id="eventInfo" class="overlay-mode" style="display: none;">
        <div class="event-info-container">
            <div class="event-info-header">
                <img src="https://fll.nexus/assets/images/icon.svg" alt="FLL Nexus" class="event-info-logo">
                <div class="event-info-title" id="eventInfoTitle">Event Information</div>
            </div>
            <div class="event-qr-container">
                <div id="eventQrCode"></div>
                <div class="event-qr-label">Scan for Event Info</div>
            </div>
        </div>
    </div>

    <!-- Match Intro Mode -->
    <div id="matchIntro" class="overlay-mode" style="display: none;">
        <div class="rkContainer">
            <div class="title" id="matchIntroTitle">Team Introductions</div>
            <div id="matchIntroContainer" class="lower">
                <table class="matchIntroTable">
                    <thead>
                        <tr>
                            <th style="display: none;">Table</th>
                            <th>Team #</th>
                            <th>Team Name</th>
                            <th>Rank</th>
                            <th>High Score</th>
                        </tr>
                    </thead>
                    <tbody id="matchIntroBody">
                        <!-- Match intro data will be dynamically inserted here -->
                    </tbody>
                </table>
            </div>
            <div id="matchIntroQrContainer" class="match-intro-qr-container">
                <div id="matchIntroQrCode"></div>
                <div class="match-intro-qr-label">
                    <img src="https://fll.nexus/assets/images/icon.svg" alt="FLL Nexus" class="qr-logo">
                    Event Info
                </div>
            </div>
        </div>
    </div>

    <script>
        const socket = io();
        let currentMode = 'matchOverlay';
        let rankingsData = [];
        let lastSeconds = 150;
        let playbuzzer = false;
        let currentRegion = '';
        let currentEventId = '';
        let qrCodeInstance = null;
        let currentSession = null;
        let sessionData = null;

        // Audio elements
        const startbell = new Audio('/static/sounds/start.mp3');
        const warning = new Audio('/static/sounds/warning.mp3');
        const stopbuzzer = new Audio('/static/sounds/stop.mp3');

        // Set volume
        startbell.volume = 0.7;
        warning.volume = 0.7;
        stopbuzzer.volume = 0.7;

        // Audio context for web audio API
        let audioContext = null;

        // Initialize audio context on first user interaction
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                console.log('Audio context initialized');
            }
        }

        // Fallback: use Web Audio API beeps if audio files don't exist
        function playBeep(frequency, duration) {
            try {
                if (!audioContext) {
                    initAudioContext();
                }

                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.value = frequency;
                oscillator.type = 'sine';

                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);

                console.log(`Playing beep at ${frequency}Hz`);
            } catch (e) {
                console.error('Audio playback error:', e);
            }
        }

        // Play audio with fallback
        function playAudio(audio, fallbackFreq = 440) {
            console.log('Attempting to play audio:', audio.src);

            audio.play().then(() => {
                console.log('Audio played successfully');
            }).catch((error) => {
                console.log('Audio file playback failed, using beep. Error:', error);
                playBeep(fallbackFreq, 0.5);
            });
        }

        // Enable audio on page load (user interaction)
        document.addEventListener('click', initAudioContext, { once: true });

        // Auto-refresh rankings at bottom of scroll (not on timer)
        let isMatchActive = false;

        function requestRankingsIfActive() {
            // Only refresh if not during a match and currently in rankings mode
            if (!isMatchActive && currentMode === 'rankingsOverlay') {
                console.log('Requesting updated rankings data...');
                socket.emit('request_rankings');
            } else if (isMatchActive) {
                console.log('Skipping rankings refresh - match in progress');
            }
        }

        function pauseRankingsRefresh() {
            isMatchActive = true;
            console.log('Rankings refresh paused - match started');
        }

        function resumeRankingsRefresh() {
            isMatchActive = false;
            console.log('Rankings refresh resumed - match ended');
            // Immediately refresh rankings after match ends if in rankings mode
            requestRankingsIfActive();
        }

        // Connection
        socket.on('connect', () => {
            console.log('Display connected to server');
            // Register as an audience display client
            socket.emit('register_client', { type: 'audience_display' });
            socket.emit('request_event_info');
            socket.emit('request_current_session');
        });

        socket.on('disconnect', () => {
            console.log('Display disconnected from server');
        });

        // Handle overlay selection
        socket.on('overlay_selection', (data) => {
            console.log('Switching to:', data.screen);
            switchOverlay(data.screen);
        });

        // Handle rankings data
        socket.on('rankings_data', (data) => {
            console.log('Received rankings:', data.rankings);
            rankingsData = data.rankings;

            // Stop current scroll animation before updating table
            const wasScrolling = currentMode === 'rankingsOverlay' && scrollAnimationId !== null;
            if (wasScrolling) {
                stopRankingsScroll();
            }

            updateRankingsTable();

            // Update match intro if it's showing
            if (currentMode === 'matchIntro') {
                updateMatchIntroTable();
            }

            // Restart scroll if we were scrolling
            if (wasScrolling) {
                setTimeout(() => {
                    startRankingsScroll();
                }, 500);
            }
        });

        // Handle timer updates
        socket.on('timer_data', (data) => {
            const seconds = data.seconds || 0;
            console.log(`Timer update: ${seconds} seconds (last: ${lastSeconds})`);
            updateTimer(seconds);

            // Pause rankings refresh when match starts (timer goes from 150 to 149)
            if (seconds == 149 && lastSeconds == 150) {
                pauseRankingsRefresh();
            }

            // Resume rankings refresh when match ends (timer reaches 0)
            if (seconds == 0 && lastSeconds > 0) {
                resumeRankingsRefresh();
            }

            // Also resume if timer is reset back to 150
            if (seconds == 150 && lastSeconds < 150 && lastSeconds > 0) {
                resumeRankingsRefresh();
            }

            // Audio cues based on timer
            // Start bell at 2:29 (when countdown begins from 2:30)
            if (seconds == 149 && lastSeconds == 150) {
                console.log('ðŸ”” Playing start bell');
                playAudio(startbell, 800);
            }

            // Warning at 30 seconds
            if (seconds == 30) {
                console.log('âš ï¸ Playing warning sound');
                playbuzzer = true;
                playAudio(warning, 600);
            }

            // Stop buzzer at 0
            if (seconds == 0 && playbuzzer) {
                console.log('ðŸš¨ Playing stop buzzer');
                playAudio(stopbuzzer, 400);
                playbuzzer = false;
            }

            lastSeconds = seconds;
        });

        // Handle event info
        socket.on('event_info', (data) => {
            if (data.event_name) {
                document.querySelector('.eventTitle').textContent = data.event_name;
                document.getElementById('eventInfoTitle').textContent = data.event_name;
            }

            // Update QR code if region or event_id changed
            if (data.region && data.event_id) {
                if (data.region !== currentRegion || data.event_id !== currentEventId) {
                    currentRegion = data.region;
                    currentEventId = data.event_id;
                    updateQRCode();
                    updateEventQRCode();
                    updateMatchIntroQRCode();
                }
            }
        });

        // Handle session updates
        socket.on('session_update', (data) => {
            console.log('Session updated:', data);
            currentSession = data.session;
            // Request schedule data to get session details
            socket.emit('request_schedule');
        });

        // Handle schedule data
        socket.on('schedule_data', (data) => {
            console.log('Received schedule data:', data);
            if (data.schedule && currentSession !== null) {
                sessionData = data.schedule[currentSession];
                if (currentMode === 'matchIntro') {
                    updateMatchIntroTable();
                }
            }
        });

        // Generate or update QR code for FLL Nexus leaderboard
        function updateQRCode() {
            if (!currentRegion || !currentEventId) {
                console.log('Cannot generate QR code - missing region or event_id');
                return;
            }

            const leaderboardUrl = `https://fll.nexus/region/${currentRegion}/event/${currentEventId}/leaderboard`;
            console.log('Generating QR code for:', leaderboardUrl);

            const qrContainer = document.getElementById('qrcode');

            // Clear existing QR code
            qrContainer.innerHTML = '';

            // Generate new QR code
            qrCodeInstance = new QRCode(qrContainer, {
                text: leaderboardUrl,
                width: 150,
                height: 150,
                colorDark: "#000000",
                colorLight: "#ffffff",
                correctLevel: QRCode.CorrectLevel.M
            });
        }

        // Generate or update QR code for event info page
        function updateEventQRCode() {
            if (!currentRegion || !currentEventId) {
                console.log('Cannot generate event QR code - missing region or event_id');
                return;
            }

            const eventUrl = `https://fll.nexus/region/${currentRegion}/event/${currentEventId}`;
            console.log('Generating event QR code for:', eventUrl);

            const qrContainer = document.getElementById('eventQrCode');

            // Clear existing QR code
            qrContainer.innerHTML = '';

            // Generate new QR code
            new QRCode(qrContainer, {
                text: eventUrl,
                width: 300,
                height: 300,
                colorDark: "#000000",
                colorLight: "#ffffff",
                correctLevel: QRCode.CorrectLevel.M
            });
        }

        // Generate or update QR code for match intro
        function updateMatchIntroQRCode() {
            if (!currentRegion || !currentEventId) {
                console.log('Cannot generate match intro QR code - missing region or event_id');
                return;
            }

            const eventUrl = `https://fll.nexus/region/${currentRegion}/event/${currentEventId}`;
            console.log('Generating match intro QR code for:', eventUrl);

            const qrContainer = document.getElementById('matchIntroQrCode');

            // Clear existing QR code
            qrContainer.innerHTML = '';

            // Generate new QR code
            new QRCode(qrContainer, {
                text: eventUrl,
                width: 150,
                height: 150,
                colorDark: "#000000",
                colorLight: "#ffffff",
                correctLevel: QRCode.CorrectLevel.M
            });
        }

        // Switch between overlay modes
        function switchOverlay(mode) {
            // Stop rankings scroll if switching away
            if (currentMode === 'rankingsOverlay' && mode !== 'rankingsOverlay') {
                stopRankingsScroll();
            }

            // Hide all overlays
            document.querySelectorAll('.overlay-mode').forEach(overlay => {
                overlay.style.display = 'none';
            });

            // Show selected overlay with fade in
            const selectedOverlay = document.getElementById(mode);
            if (selectedOverlay) {
                selectedOverlay.style.display = 'block';
                selectedOverlay.style.opacity = '0';
                setTimeout(() => {
                    selectedOverlay.style.transition = 'opacity 1s';
                    selectedOverlay.style.opacity = '1';
                }, 10);
            }

            currentMode = mode;

            // Request fresh rankings and start auto-scroll for rankings
            if (mode === 'rankingsOverlay') {
                requestRankingsIfActive(); // Fetch latest rankings when entering rankings mode
                setTimeout(() => {
                    startRankingsScroll();
                }, 1000); // Wait for fade in
            }

            // Request data for match intro mode
            if (mode === 'matchIntro') {
                socket.emit('request_rankings'); // Get latest rankings
                socket.emit('request_current_session'); // Get current session
                socket.emit('request_schedule'); // Get schedule data
            }
        }

        // Update rankings table - show ALL teams
        function updateRankingsTable() {
            const tbody = document.getElementById('rankingsBody');
            tbody.innerHTML = '';

            if (rankingsData.length === 0) return;

            console.log(`Rendering all ${rankingsData.length} teams in rankings table`);

            for (let i = 0; i < rankingsData.length; i++) {
                const team = rankingsData[i];
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${i + 1}</td>
                    <td>${team.team_number}</td>
                    <td class="team-name">${team.name}</td>
                    <td>${team.high_score}</td>
                    <td>${team.total_rounds}</td>
                `;
                tbody.appendChild(row);
            }
        }

        // Update Match Intro table - show teams at tables for current session
        function updateMatchIntroTable() {
            const tbody = document.getElementById('matchIntroBody');
            const titleElement = document.getElementById('matchIntroTitle');
            tbody.innerHTML = '';

            if (!sessionData || !sessionData.teams) {
                console.log('No session data available');
                tbody.innerHTML = '<tr><td colspan="5" style="text-align: center;">No session selected</td></tr>';
                titleElement.textContent = 'Team Introductions';
                return;
            }

            console.log('Updating match intro table with session data:', sessionData);

            // Update title with session type and number
            const sessionType = sessionData.practice ? 'Practice' : 'Official';
            const sessionNumber = currentSession !== null ? currentSession + 1 : '?';
            titleElement.textContent = `${sessionType} - Session ${sessionNumber}`;

            // Get teams from session - preserve original structure to maintain table indices
            const teams = sessionData.teams;

            // Handle teams as either array or object
            if (Array.isArray(teams)) {
                // Array format: iterate through each position, index represents table position
                teams.forEach((teamNumber, index) => {
                    if (teamNumber === null || teamNumber === undefined) {
                        return; // Skip empty tables
                    }

                    // Table numbers start at 1, array index starts at 0
                    const tableNumber = index + 1;
                    const tableName = `Table ${tableNumber}`;

                    // Find team in rankings to get rank and high score
                    let rank = '-';
                    let highScore = '-';
                    let teamName = `Team ${teamNumber}`;

                    if (rankingsData.length > 0) {
                        const teamIndex = rankingsData.findIndex(t => String(t.team_number) === String(teamNumber));
                        if (teamIndex !== -1) {
                            rank = teamIndex + 1;
                            highScore = rankingsData[teamIndex].high_score;
                            teamName = rankingsData[teamIndex].name;
                        }
                    }

                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td style="display: none;">${tableName}</td>
                        <td>${teamNumber}</td>
                        <td class="team-name">${teamName}</td>
                        <td>${rank}</td>
                        <td>${highScore}</td>
                    `;
                    tbody.appendChild(row);
                });
            } else if (typeof teams === 'object') {
                // Object format: use keys as table indices
                Object.entries(teams).forEach(([tableIndex, teamNumber]) => {
                    if (teamNumber === null || teamNumber === undefined) {
                        return; // Skip empty tables
                    }

                    // Convert string key to number and add 1 for display
                    const tableNumber = parseInt(tableIndex) + 1;
                    const tableName = `Table ${tableNumber}`;

                    // Find team in rankings to get rank and high score
                    let rank = '-';
                    let highScore = '-';
                    let teamName = `Team ${teamNumber}`;

                    if (rankingsData.length > 0) {
                        const teamIndex = rankingsData.findIndex(t => String(t.team_number) === String(teamNumber));
                        if (teamIndex !== -1) {
                            rank = teamIndex + 1;
                            highScore = rankingsData[teamIndex].high_score;
                            teamName = rankingsData[teamIndex].name;
                        }
                    }

                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td style="display: none;">${tableName}</td>
                        <td>${teamNumber}</td>
                        <td class="team-name">${teamName}</td>
                        <td>${rank}</td>
                        <td>${highScore}</td>
                    `;
                    tbody.appendChild(row);
                });
            }

            // Count non-null teams for logging
            const teamCount = Array.isArray(teams)
                ? teams.filter(t => t !== null && t !== undefined).length
                : Object.values(teams).filter(t => t !== null && t !== undefined).length;

            console.log(`Rendered ${teamCount} teams in match intro table`);
        }

        // Auto-scroll rankings with smooth continuous animation
        let scrollAnimationId = null;
        let baseScrollSpeed = 50; // base pixels per second

        function startRankingsScroll() {
            const container = document.getElementById('rankingsContainer');
            if (!container) {
                console.log('Rankings container not found');
                return;
            }

            // Stop any existing animation - CRITICAL to prevent multiple loops
            stopRankingsScroll();

            container.scrollTop = 0;
            const table = container.querySelector('table');
            if (!table) {
                console.log('Rankings table not found');
                return;
            }

            // Use a function to get fresh measurements (in case table changes)
            function getMeasurements() {
                const tableHeight = table.scrollHeight;
                const containerHeight = container.clientHeight;
                const scrollDistance = tableHeight - containerHeight;
                return { tableHeight, containerHeight, scrollDistance };
            }

            let { tableHeight, containerHeight, scrollDistance } = getMeasurements();

            console.log(`Rankings scroll info: table=${tableHeight}px, container=${containerHeight}px, distance=${scrollDistance}px`);

            if (scrollDistance <= 0) {
                console.log('No scrolling needed - content fits in container');
                return; // No need to scroll if content fits
            }

            // Adjust speed so it takes at least 10 seconds to scroll through
            const minScrollDuration = 12500; // milliseconds
            const calculatedSpeed = (scrollDistance / minScrollDuration) * 1000;
            const scrollSpeed = Math.max(baseScrollSpeed, calculatedSpeed);
            console.log(`Using scroll speed: ${scrollSpeed} px/s (calculated: ${calculatedSpeed}, base: ${baseScrollSpeed})`);


            let lastTime = performance.now();
            let pauseTimer = 0;
            const pauseDuration = 5000; // Pause at top and bottom (5 seconds)
            let isPaused = true; // Start paused at top
            let hasReachedBottom = false;
            let frameCount = 0;

            console.log('Starting rankings scroll animation');

            function animate(currentTime) {
                // Safety check - ensure we're the only animation running
                if (!container || currentMode !== 'rankingsOverlay') {
                    console.log('Stopping scroll - mode changed or container gone');
                    scrollAnimationId = null;
                    return; // Stop if container is gone or mode changed
                }

                const deltaTime = currentTime - lastTime;
                lastTime = currentTime;
                frameCount++;

                if (isPaused) {
                    pauseTimer += deltaTime;
                    if (pauseTimer >= pauseDuration) {
                        isPaused = false;
                        pauseTimer = 0;

                        // If we just finished pausing at bottom, fetch new rankings and reset to top
                        if (hasReachedBottom) {
                            console.log('Finished pausing at bottom, requesting updated rankings');
                            requestRankingsIfActive(); // Refresh rankings before resetting to top
                            console.log('Resetting scroll to top');
                            container.scrollTop = 0;
                            hasReachedBottom = false;
                            isPaused = true; // Pause at top before scrolling again
                        }
                    }
                } else {
                    // Smooth scroll
                    const scrollAmount = (scrollSpeed * deltaTime) / 1000;
                    container.scrollTop += scrollAmount;

                    // Only refresh measurements every 60 frames (~1 second at 60fps) to avoid layout thrashing
                    if (frameCount % 60 === 0) {
                        const currentMeasurements = getMeasurements();
                        scrollDistance = currentMeasurements.scrollDistance;
                    }

                    // Check if reached bottom
                    if (container.scrollTop >= scrollDistance - 1) {
                        console.log(`Reached bottom, pausing. ScrollTop: ${container.scrollTop}/${scrollDistance}`);
                        container.scrollTop = scrollDistance;
                        isPaused = true;
                        pauseTimer = 0;
                        hasReachedBottom = true;
                    }
                }

                scrollAnimationId = requestAnimationFrame(animate);
            }

            scrollAnimationId = requestAnimationFrame(animate);
        }

        function stopRankingsScroll() {
            if (scrollAnimationId) {
                cancelAnimationFrame(scrollAnimationId);
                scrollAnimationId = null;
            }
        }

        // Update timer display
        function updateTimer(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = seconds % 60;
            const timeString = `${minutes}:${secs.toString().padStart(2, '0')}`;

            document.getElementById('timer').textContent = timeString;

            // Color coding
            const timerEl = document.getElementById('timer');
            if (seconds <= 10) {
                timerEl.className = 'text-danger';
            } else if (seconds <= 30) {
                timerEl.className = 'text-warning';
            } else {
                timerEl.className = '';
            }
        }

        // Generate table overlays dynamically (for match mode)
        function generateTableOverlay(tableId, tableName) {
            return `
                <div class="table text-center">
                    <div class="tableName">${tableName}</div>
                    <div id="${tableId}TeamName" class="teamName">-</div>
                    <div id="${tableId}TeamNumber" class="teamNumber">Team -</div>
                </div>
            `;
        }

        // Initialize with default tables
        window.addEventListener('load', () => {
            const container = document.getElementById('moTableContainer');
            const tables = ['Table 1', 'Table 2', 'Table 3', 'Table 4'];

            tables.forEach((tableName, index) => {
                container.innerHTML += generateTableOverlay(`table${index + 1}`, tableName);
            });

            // Request initial data
            socket.emit('request_rankings');

            // Load sponsor logos
            loadSponsorLogos();
        });

        // Sponsor slideshow
        let sponsorLogos = [];
        let currentSponsorIndex = 0;
        let sponsorInterval = null;

        async function loadSponsorLogos() {
            try {
                // Fetch list of sponsor logos from server
                const response = await fetch('/api/sponsor_logos');
                const data = await response.json();
                sponsorLogos = data.logos || [];

                console.log(`Loaded ${sponsorLogos.length} sponsor logos:`, sponsorLogos);

                // Create sponsor logo elements
                const container = document.getElementById('spLowerThird');
                container.innerHTML = '';

                if (sponsorLogos.length === 0) {
                    console.log('No sponsor logos found');
                    return;
                }

                sponsorLogos.forEach((logo, index) => {
                    const logoElement = document.createElement('object');
                    logoElement.type = 'image/svg+xml';
                    logoElement.data = `/static/images/sponsors/${logo}`;
                    logoElement.className = 'spLogo';
                    logoElement.id = `sponsor-${index}`;
                    logoElement.style.display = index === 0 ? 'block' : 'none';
                    logoElement.style.opacity = index === 0 ? '1' : '0';
                    logoElement.style.transition = 'opacity 0.5s';
                    container.appendChild(logoElement);
                });
            } catch (error) {
                console.error('Error loading sponsor logos:', error);
                sponsorLogos = [];
            }
        }

        function startSponsorSlideshow() {
            if (sponsorLogos.length <= 1) return;

            // Reset to first sponsor (but don't animate since it's already shown)
            currentSponsorIndex = 0;

            // Ensure first sponsor is visible and others are hidden
            sponsorLogos.forEach((logo, i) => {
                const element = document.getElementById(`sponsor-${i}`);
                if (element) {
                    if (i === 0) {
                        element.style.display = 'block';
                        element.style.opacity = '1';
                    } else {
                        element.style.display = 'none';
                        element.style.opacity = '0';
                    }
                }
            });

            // Rotate sponsors every 5 seconds
            sponsorInterval = setInterval(() => {
                const nextIndex = (currentSponsorIndex + 1) % sponsorLogos.length;
                showSponsor(nextIndex);
                currentSponsorIndex = nextIndex;
            }, 5000);
        }

        function stopSponsorSlideshow() {
            if (sponsorInterval) {
                clearInterval(sponsorInterval);
                sponsorInterval = null;
            }
        }

        function showSponsor(index) {
            const currentElement = document.getElementById(`sponsor-${currentSponsorIndex}`);
            const nextElement = document.getElementById(`sponsor-${index}`);

            if (!currentElement || !nextElement) return;

            // Fade out current sponsor
            currentElement.style.transition = 'opacity 0.5s';
            currentElement.style.opacity = '0';

            // After fade out completes, swap sponsors
            setTimeout(() => {
                currentElement.style.display = 'none';
                nextElement.style.display = 'block';
                nextElement.style.opacity = '0';

                // Force reflow to ensure the display change takes effect
                nextElement.offsetHeight;

                // Fade in next sponsor
                nextElement.style.transition = 'opacity 0.5s';
                nextElement.style.opacity = '1';
            }, 500);
        }

        // Update switchOverlay to handle sponsor slideshow
        const originalSwitchOverlay = switchOverlay;
        switchOverlay = function(mode) {
            // Stop sponsor slideshow if switching away
            if (currentMode === 'sponsors' && mode !== 'sponsors') {
                stopSponsorSlideshow();
            }

            // Call original function
            originalSwitchOverlay(mode);

            // Start sponsor slideshow if switching to sponsors
            if (mode === 'sponsors') {
                setTimeout(() => {
                    startSponsorSlideshow();
                }, 1000);
            }
        };
    </script>
</body>
</html>
